import cloudinary from '../config/cloudinaryConfig';
import moment from "moment";

import { isEmpty } from '../helpers/validation';
import { errorMessage, successMessage, status } from '../helpers/status';
import Model from '../models/models';

const gifs = new Model('gifs');
const comments = new Model('comments');

exports.createGif = async (req, res) => {

  console.log('** ** ** ** ** ** ** ** ** Uploads ** ** ** ** ** ** ** ** ** **');

  // let filename = req.files.dataFile.path;

    // Save Image To DB
    try {

      const { file } = req;
      // File Upload
      const result = await cloudinary.v2.uploader.upload(file, { tags: req.body.title }, (error, result) => {

        console.log();
        console.log('** File Upload');
        if (error) {
          console.log('** File error', error);
          console.warn(error);
        }
        console.log('* public_id for the uploaded image is generated by Cloudinary\'s service.');
        console.log('* public_id ', result.public_id);
        console.log('* url ', result.url);
      });

      const { title, share } = req.body;

      const authorid = req.body.userId;

      if (isEmpty(title) || isEmpty(share)) {
        errorMessage.error = 'title and share field cannot be empty';
        return res.status(status.bad).send(errorMessage);
      }

      const createGifQuery = `INSERT INTO gifs(title, share, authorId, imageurl, createdat, updatedat)
      VALUES($1, $2, $3, $4, $5, $6) returning *`;
      const values = [ title, share, authorid, result.url, moment(new Date()), moment(new Date()) ];

      const { rows } = await gifs.query(createGifQuery, values);
      const dbResponse = rows[0];
      const { id, imageurl, createdat } = dbResponse;

      return res.status(status.created).json({
        status: 'success',
        data: {
          gifId: id,
          message: 'GIF image successfully posted',
          createdOn: createdat,
          title,
          imageurl,
        },
      });

    } catch (error) {
      return res.status(status.error).json({
        status: error,
        error: error.message,
      });
    }
};

exports.getGif = async (req, res) => {

  const getGifQuery = 'SELECT * FROM gifs WHERE id = $1';
  let dataResponse = {};

  try {

    const { rows } = await gifs.query(getGifQuery, [req.params.id]);
    const dbResponse = rows[0];

    if (!dbResponse) {
      errorMessage.error = 'Gif Not Found!';
      return res.status(status.notfound).send(errorMessage);
    }

    dataResponse = dbResponse;

  } catch (error) {
    errorMessage.error = 'An error Occurred';
    return res.status(status.error).send(errorMessage);
  }

  const getGifCommentsQuery = 'SELECT * FROM comments WHERE postid = $1';

  try {

    const {id, title, imageurl, share, createdat} = dataResponse;

    const { rows } = await gifs.query(getGifCommentsQuery, [id]);
    const dbResponse = rows[0];

    const commentsArray = [];

    if (dbResponse !== undefined) {
      rows.map((comment) => (
          commentsArray.push({
              commentId: comment.id,
              comment: comment.description,
              authorId: comment.authorid,
          })
      ));
  }

    return res.status(status.success).json({
      status: 'success',
      data: {
        id: id,
        title: title,
        url: imageurl,
        share: share,
        comments: commentsArray,
        createdOn: createdat,
      },
    });

  } catch (error) {
    errorMessage.error = 'An error Occurred';
    return res.status(status.error).send(errorMessage);
  }

};

exports.deleteGif = async (req, res) => {

  const postId = req.params.id;
  const authorid = req.body.userId;
  const deleteGifQuery = 'DELETE FROM gifs WHERE id=$1 AND authorid = $2 returning *';

  try {
    const { rows } = await gifs.query(deleteGifQuery, [postId, authorid]);
    const dbResponse = rows[0];

    if (!dbResponse) {
      errorMessage.error = 'Gif Not Found';
      return res.status(status.notfound).send(errorMessage);
    }
    return res.status(status.success).json({
      status: 'success',
      data: {
        message: 'Gif post successfully deleted',
      },
    });
  } catch (error) {
    return res.status(status.error).send(error);
  }
};


exports.commentGif = async (req, res) => {

  const postId = req.params.id;
  const { description, userId } = req.body;
  const authorId = userId;

  const findGifQuery = 'SELECT * FROM gifs WHERE id=$1';
  const commentGif = `INSERT INTO comments(description, authorid, postid, updatedAt, createdAt)
      VALUES($1, $2, $3, $4, $5) returning *`;

  const createdat = moment(new Date());
  const updatedat = moment(new Date());

  const values = [description, authorId, postId, createdat, updatedat];
  let title;

  try {
    const { rows } = await gifs.query(findGifQuery, [postId]);
    const dbResponse = rows[0];

    if (!dbResponse) {
      errorMessage.error = 'Gif Cannot be found';
      return res.status(status.notfound).send(errorMessage);
    }

    title  = dbResponse.title;

  } catch (error) {
    errorMessage.error = 'Operation was not successful';
    return res.status(status.error).send(errorMessage);
  }

  try {
    const { rows } = await comments.query(commentGif, values);
    const dbResponse = rows[0];
    if (!dbResponse) {
      errorMessage.error = 'Error while adding Comment!';
      return res.status(status.conflict).send(errorMessage);
    }

    const { createdat } = dbResponse;

    return res.status(status.created).json({
      status: 'success',
      data: {
        message: 'Comment successfully created',
        createdOn: createdat,
        gifTitle: title,
        // article: article,
        comment: description,
      },
    });

  } catch (error) {
    errorMessage.error = 'Operation was not successful';
    return res.status(status.error).send(errorMessage);
  }
};
